import
  std/[macros, sequtils, strutils, parseutils]

import ../macros/argpass

import ../core/[all, code_errors]

macro closureToCdeclImpl(c: typed): untyped =
  discard

func closureToCdecl*[C: proc {.closure.}](c: C): auto =
  closureToCdeclImpl(c)

func splitClosure*[C: proc {.closure.}](c: C): auto =
  return (impl: cast[typeof(closureToCdecl(c))](rawProc(c)), env: rawEnv(c))

type
  cchar16* = uint16
  cchar32* = uint32
  cwchar* = uint32
  nullptr_t* = typeof(nil)

# QUESTION argument might contain fully namespaced entry identifier, with
# all arguments specified, like `main(const*[char],int): void`? This could
# be used by other tools. Or should I generate full name directly?
# `static[HcIdent]`.

template hcgen*(arg: static[string]) {.pragma.}
  ## Entries annotated with this pragma are automatically generated by
  ## external tooling. This pragma itself does not do anything, but hcparse
  ## should use it to intellegently override generated sources, without
  ## breaking manually added code.

template hcedit*(arg: static[string]) {.pragma.}
  ## Similar to [[code:hcgen]], but used to anotate entries that were
  ## originally generated by hcparse, but then manually modified, and no
  ## longer need to be auto-updated when new source is generated.

type
  UArray*[T] = UncheckedArray[T]
  PUarray*[T] = ptr UncheckedArray[T]

template `+`*[T](p: ptr T, offset: SomeInteger): ptr T =
  cast[ptr type(p[])](cast[ByteAddress](p) +% int(offset) * sizeof(p[]))

template `+=`*[T](p: ptr T, offset: SomeInteger) =
  p = p + offset

template `-`*[T](p: ptr T, offset: SomeInteger): ptr T =
  cast[ptr type(p[])](cast[ByteAddress](p) -% int(offset) * sizeof(p[]))

template `-=`*[T](p: ptr T, offset: SomeInteger) =
  p = p - offset

template `[]`*[T](p: ptr T, offset: SomeInteger): T =
  (p + offset)[]

template `[]=`*[T](p: ptr T, offset: SomeInteger, val: T) =
  (p + offset)[] = val

proc allocPUarray*[T](size: Natural): PUarray[T] =
  cast[PUarray[T]](alloc(size * sizeof(T)))

proc allocPUarray*[T, R](elements: array[R, T]): PUarray[T] =
  discard # TODO

proc deallocPUarray*[T](arr: PUarray[T]) =
  dealloc(cast[pointer](arr))

template toPUarray*[T](p: ptr T): PUarray[T] = cast[PUarray[T]](p)
template toPtr*[T](p: PUArray[T]): ptr T = cast[ptr T](p)

template toPtr*[T](r: ref T): ptr T = cast[ptr T](r)
template toPUarray*[T](r: ref T): PUarray[T] = cast[PUarray[T]](r)

iterator items*[T](arr: PUarray[T], size: int): T =
  var idx = 0
  while idx < size:
    yield arr[][idx]
    inc idx

iterator pairs*[T](arr: PUarray[T], size: int): (int, T) =
  var idx = 0
  while idx < size:
    yield (idx, arr[][idx])
    inc idx

template subArrayPtr*[T](arr: PUArray[T], idx: SomeInteger): PUarray[T] =
  toPUarray(toPtr(arr) + idx)

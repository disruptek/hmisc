#+title: readme

Collection of miscellaneous helper algorithms and types.

* Toplevel

** ~hmisc/hexceptions~ [[https://haxscramper.github.io/hmisc-doc/src/hmisc/hexceptions.html][documentation]]

One of *THE* features of this library - effortlessly generate
annotations for source code. Show exact line in the source code and
provide custom annotations.

#+begin_src nim :exports both
  {.define(plainStdout).} # Output is colored by default, disable for
                          # readme example
  import hmisc/hexceptions

  macro test(a: untyped): untyped =
    raise toCodeError({
      a[2] : "Third element in array",
      a[0] : "Array starts here\nMultiline annotations",
      a[5] : "Annotation for part on the different line"
    }, "Annotation for array error")

  test([1,2,3,4,
        5,6])

#+end_src

#+RESULTS:
#+begin_example
Annotation for array error

 11
 14:10 test([1,2,3,4,
             ^   ^
             |   |
             |   Third element in array
             |
             Array starts here
             Multiline annotations

 12   test([1,2,3,4,
 15:8       5,6])
              ^
              |
              Annotation for part on the different line



Raised in :0


 [CodeError:ObjectType]
#+end_example


* Macros

** ~hmisc/macros/obj_field_macros~ [[https://haxscramper.github.io/hmisc-doc/src/hmisc/macros/obj_field_macros.html][documentation]]

- ~parallelFieldPairs~ - iterate case object fields in parallel
- ~getFields~ - construct sequence of [[https://haxscramper.github.io/hmisc-doc/src/hmisc/types/hnim_ast.html#Field][Field]] types from node.

** ~hmisc/macros/iflet~

Rust-like iflet. Get value from ~Option[T]~ only if it contains
something, otherwise execute ~else~.

#+begin_src nim :exports both
import options
import hmisc/macros/iflet

iflet (val = some(12)):
  echo typeof val

iflet (val = none(int)):
  echo "???"
else:
  echo "no value"
#+end_src

#+RESULTS:
: int
: no value

* Algorithms
  :PROPERTIES:
  :header-args:nim:+ :import hmisc/algo/halgorithm
  :END:

** ~hmisc/algo/halgorithm~ [[https://haxscramper.github.io/hmisc-doc/src/hmisc/algo/halgorithm.html][documentation]]

- predicates
  - ~allOfIt~
  - ~anyOfIt~
  - ~noneOfIt~
  - ~==~ for Option-Val comparison
- working with sequences
  - ~maxIt~
  - ~disjointIter~
  - ~last~
- working with strings
  - ~joinw~, ~joinq~, ~joinl~, ~joinkv~ - join on whitespaces,
    whitespace + quote each string, newlines or key-value pairs.
  - ~wrap~ - wrap strings in delimiters. Has convinience overload for
    ~.wrap("()")~ that automatically determines starting/ending
    wrapper strings.
  - Multiple overloads for ~join~ and ~startsWith~
  - ~enclosedIn~ - check if string is wrapped in delimiters
  - ~dedent~ - derease indentation for multiline string
- other
  - ~ifSomeIt~ - same as ~opt.isSome() and (let it = opt.get();
    predicate)~
  - ~testEq~ - compare two objects. If they are different print first
    mismatching line in their string representation.
  - ~assertEq~ - compare objects using ~testEq~, raise on failed
    comparison.

#+begin_src nim :exports both
import hmisc/algo/halgorithm

block:
  echo "-- withIt --"
  let immutable = (a: 12, b: 12)
  echo immutable.withIt do:
    it.a = 909

block:
  echo "-- withResIt --"
  let immutable = (a: 12, b: "eee")
  echo immutable.withResIt do:
    it.a += 999
    $it.a & it.b

block:
  echo "-- join* --"
  echo {1 : "22", 3: "333"}.joinkv().join()
#+end_src

#+RESULTS:
: -- withIt --
: (a: 909, b: 12)
: -- withResIt --
: 1011eee
: -- join* --
: 0 = (1, "22") 1 = (3, "333")



** ~hmisc/algo/hseq_mapping~

- ~deduplicateIt~
- ~mapPairs~ :: ~mapIt~ for types that implement ~pairs~ iterator, or
  ~items~ that return tuple, or sequence of tuples. Inject index of
  the item, ~lhs~ (first element) and ~rhs~ (second element). Should
  correctly handle ~{.requiresinit.}~ fields.

** ~hmisc/algo/htree_mapping~

- ~mapItBFStoSeq~ :: iterate over tree in BFS order, store mapping
  result in sequence.
- ~iterateItBFS~ :: iterate over tree in BFS order
- ~iterateItDFS~ :: iterate over tree in DFS order. Uses iterative DFS
  instead of recursive call.
- ~mapItDFS~ :: ~mapIt~ for converting trees in DFS order

* Types

** ~hmisc/types/hprimitives~

- ~StrBlock~ :: ~seq[string]~ + getting height/width
- ~ArrSize~ :: Size of 2d array as distinct type
- ~ArrRange~ :: range of elements in 1d array + lots of helper functions
  - move left/right edge with correctness checks (assertions)
  - check if position is in range
  - count number of 'middles' in sequence
  - check if range is a single point
  - find overlaps between two ranges
  - iterate over indices in cartesian product of two ranges - for
    example all cells in particular ~[row-range] X [col-range]~.

** ~hmisc/types/seq2d~

*** ~Seq2D~

Always-rectangular 2d sequence of items. Public API prevents
modification that will make it non-rectangular.

Helper functions are provided for

- iterating elements
  - columns :: ~itercols~
  - rows :: ~iterrows~, ~items~ for row without index, ~pairs~ for
    rows with index.
  - itercells :: each element + global position ~(row, col)~
  - iterSomeCells :: each cell that is not ~none(T)~ + position ~(row,
    col)~
- mapping elements
  - map 2d sequence :: ~mapIt2d~ - each element is injected as ~it~
  - maximize value over rowmns :: ~maximizeRowIt~ get value for each
    element in row, return max one. Repeat for each row
  - maximize value over columns :: ~maximizeColIt~ get value for each
    element in column, return max one. Repeat for each column.
- modification
  - single elements :: All sorts of overload for ~[]~ and ~[]=~ operators
  - rows :: ~appendRow~, ~insertRow~, ~addHeader~
  - columns :: ~insertCol~
  - whole grid :: ~fillToSize~

Helper functions for getting row/col count, iterating over
rows/columns

*** ~MulticellGrid~

Same as ~Seq2D~ (always rectangular with API preventing unwanted
modifications). Supports 'mutlicell' elements.

** ~hmisc/types/htrie~

Implementation of =trie= data structure. Not sure about performance,
mostly made for the sake of abstraction and API (storing list of paths
in tree).

** ~hmisc/types/hvariant~

Sum type as generic in nim. Similar to ~std::variant< ... >~. Not
really useful actually - after I wrote it there has never been a
situation where I case objects were just 'too much'.

** ~hmisc/types/colorstring~

Easier manipulation of colored strings in terminal. Support splitting
regular strin in same-color chunks, finding 'visible' length of the
string (as printed in terminal). Helper functions like ~toYellow()~ or
~toRed()~ to make creation of the colored strings simpler. All
attributes from ~terminal~ module are supported (fg/bg colors and
modifiers).

Provides two types for colored text - ~ColoredString~ (string +
styling) and ~ColoredRune~ (unicode rune + styling).


* Contribution & development

Most of the features in this library were implemented on
/do-it-when-I-need-it/ basis. Some of them are tested quite
extensively (sequence and tree mappings, colored strings), but more
unit test are always welcome. If you consider contributing and have
any questions about implementation or just want to clarify some things
(documentation might need more attention) feel free to join my [[https://discord.gg/ZnBB4E][discord
server]] and ask questions there.

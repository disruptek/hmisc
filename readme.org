#+title: readme

Collection of miscellaneous helper algorithms and types.

* Toplevel

** ~hmisc/hexceptions~ [[https://haxscramper.github.io/hmisc-doc/src/hmisc/hexceptions.html][documentation]]

One of features of this library - easily generate annotations for
source code. Show exact line in the source code and provide custom
annotations.

#+begin_src nim :exports both
  {.define(plainStdout).} # Output is colored by default, disable for
                          # readme example
  import hmisc/hexceptions

  macro test(a: untyped): untyped =
    raise toCodeError({
      a[2] : "Third element in array",
      a[0] : "Array starts here\nMultiline annotations",
      a[5] : "Annotation for part on the different line"
    }, "Annotation for array error")

  test([1,2,3,4,
        5,6])

#+end_src

#+RESULTS:
#+begin_example
Annotation for array error

 11
 14:10 test([1,2,3,4,
             ^   ^
             |   |
             |   Third element in array
             |
             Array starts here
             Multiline annotations

 12   test([1,2,3,4,
 15:8       5,6])
              ^
              |
              Annotation for part on the different line



Raised in :0


 [CodeError:ObjectType]
#+end_example


* Macros

** ~hmisc/macros/obj_field_macros~ [[https://haxscramper.github.io/hmisc-doc/src/hmisc/macros/obj_field_macros.html][documentation]]

- ~parallelFieldPairs~ - iterate case object fields in parallel
- ~getFields~ - construct sequence of [[https://haxscramper.github.io/hmisc-doc/src/hmisc/types/hnim_ast.html#Field][Field]] types from node.

** ~hmisc/macros/iflet~

Rust-like iflet. Get value from ~Option[T]~ only if it contains
something, otherwise execute ~else~.

#+begin_src nim :exports both
import options
import hmisc/macros/iflet

iflet (val = some(12)):
  echo typeof val

iflet (val = none(int)):
  echo "???"
else:
  echo "no value"
#+end_src

#+RESULTS:
: int
: no value

* Algorithms
  :PROPERTIES:
  :header-args:nim:+ :import hmisc/algo/halgorithm
  :END:

** ~hmisc/algo/halgorithm~ [[https://haxscramper.github.io/hmisc-doc/src/hmisc/algo/halgorithm.html][documentation]]

- predicates
  - ~allOfIt~
  - ~anyOfIt~
  - ~noneOfIt~
  - ~==~ for Option-Val comparison
- working with sequences
  - ~maxIt~
  - ~disjointIter~
  - ~last~
- working with strings
  - ~joinw~, ~joinq~, ~joinl~, ~joinkv~ - join on whitespaces,
    whitespace + quote each string, newlines or key-value pairs.
    Mostly useful in ~strformat.&~ - can write ~{somevar.join()}~
    instead of ~{somevar.join(\"\\n\")}~
  - ~wrap~ - wrap strings in delimiters. Has convinience overload for
    ~.wrap("()")~ that automatically determines starting/ending
    wrapper strings.
  - Multiple overloads for ~join~ and ~startsWith~
  - ~enclosedIn~ - check if string is wrapped in delimiters
  - ~dedent~ - decease indentation for multiline string
  - ~camelSplit~ - split string as camel case identifier
  - ~abbrevCamel~ - /camelCase/ abbreviation search.
  - Several variations of ~dropPrefix~, ~addPrefix~, ~startsWith~,
    ~addSuffix~ for less common use cases
  - Filtering sequence of strings by prefix
  - Dropping subsequence in strings
  - Finding common prefix in sequence of strings
- other
  - ~ifSomeIt~ - same as ~opt.isSome() and (let it = opt.get();
    predicate)~
  - ~testEq~ - compare two objects. If they are different print first
    mismatching line in their string representation.
  - ~assertEq~ - compare objects using ~testEq~, raise on failed
    comparison.

#+begin_src nim :exports both
  import hmisc/algo/halgorithm, strformat
  let v = @["w234", "333"]

  echo ": ", &"{v.joinq()}"

  block:
    echo "-- withIt --"
    let immutable = (a: 12, b: 12)
    echo immutable.withIt do:
      it.a = 909

  block:
    echo "-- withResIt --"
    let immutable = (a: 12, b: "eee")
    echo immutable.withResIt do:
      it.a += 999
      $it.a & it.b

  block:
    echo "-- join* --"
    echo {1 : "22", 3: "333"}.joinkv().join()

  block:
    echo "-- abbrevCamel --"
    echo abbrevCamel("AA", @["ABA", "AZZ", "A)"])
#+end_src

#+RESULTS:
: : "w234" "333"
: -- withIt --
: (a: 909, b: 12)
: -- withResIt --
: 1011eee
: -- join* --
: 0 = (1, "22") 1 = (3, "333")
: -- abbrevCamel --
: @["ABA"]

** ~hmisc/algo/hseqdistance~ [[https://haxscramper.github.io/hmisc-doc/src/hmisc/algo/hseqdistance.html][documentation]]

Fuzzy string matching and generic longest common subsequece
implementation

- ~longestCommonSubsequence~ - generic implementation of LCS algorithm
  for ~seq[T]~
- ~fuzzyMatch~ - weighted sequence fuzzy match. Compare each element
  in the sequence to pattern and assign similarity score. Should
  behave similarly to ~fzf~ or sublime text. Reimplementation of
  [[https://www.forrestthewoods.com/blog/reverse_engineering_sublime_texts_fuzzy_match/]['Reverse engineering subtime text's fuzzy match']]. I haven't used it
  in any interactive applications as of yet, but there are some unit
  tests. It has generic implementation and somewhat annoying to use,
  but provides very flexible interface, allowing to completely
  customize how fuzzy matching is performed.

#+begin_src nim
  import hmisc/doc_examples

  echo "# ~~~~ leading / ~~~~ #\n"
  matchTest "//hell.txt", "/nice/we/hell.txt":
    if other[matches[0]] == '/':
      1000 # high cost if have exact match with starting /
    else:
      matches.sum()

  echo "\n# ~~~~ no leading / ~~~~ #\n"
  matchTest "nicehell.txt", "/nice/we/hell.txt":
    if other[matches[0]] == '/':
      1000
    else:
      matches.sum()
#+end_src

#+RESULTS:
: # ~~~~ leading / ~~~~ #
:
: input: /nice/we/hell.txt //hell.txt :1000
: match: /    /   hell.txt
:
: # ~~~~ no leading / ~~~~ #
:
: input: /nice/we/hell.txt nicehell.txt :113
: match:  nic   e hell.txt




todo:

- [ ] levenstein distance
- [ ] Damerauâ€“Levenshtein distance
- [ ] generate diffs for two sequences



** ~hmisc/algo/hseq_mapping~

- ~deduplicateIt~
- ~mapPairs~ :: ~mapIt~ for types that implement ~pairs~ iterator, or
  ~items~ that return tuple, or sequence of tuples. Inject index of
  the item, ~lhs~ (first element) and ~rhs~ (second element). Should
  correctly handle ~{.requiresinit.}~ fields.

** ~hmisc/algo/htree_mapping~

- ~mapItBFStoSeq~ :: iterate over tree in BFS order, store mapping
  result in sequence.
- ~iterateItBFS~ :: iterate over tree in BFS order
- ~iterateItDFS~ :: iterate over tree in DFS order. Uses iterative DFS
  instead of recursive call.
- ~mapItDFS~ :: ~mapIt~ for converting trees in DFS order

* Types


** ~hmisc/types/hprimitives~

- ~StrBlock~ :: ~seq[string]~ + getting height/width
- ~ArrSize~ :: Size of 2d array as distinct type
- ~ArrRange~ :: range of elements in 1d array + lots of helper functions
  - move left/right edge with correctness checks (assertions)
  - check if position is in range
  - count number of 'middles' in sequence
  - check if range is a single point
  - find overlaps between two ranges
  - iterate over indices in cartesian product of two ranges - for
    example all cells in particular ~[row-range] X [col-range]~.

** ~hmisc/types/seq2d~

*** ~Seq2D~

Always-rectangular 2d sequence of items. API prevents modification
that will make it non-rectangular.

Helper functions are provided for

- iterating elements
  - columns :: ~itercols~
  - rows :: ~iterrows~, ~items~ for row without index, ~pairs~ for
    rows with index.
  - itercells :: each element + global position ~(row, col)~
  - iterSomeCells :: each cell that is not ~none(T)~ + position ~(row,
    col)~
- mapping elements
  - map 2d sequence :: ~mapIt2d~ - each element is injected as ~it~
  - maximize value over rowmns :: ~maximizeRowIt~ get value for each
    element in row, return max one. Repeat for each row
  - maximize value over columns :: ~maximizeColIt~ get value for each
    element in column, return max one. Repeat for each column.
- modification
  - single elements :: All sorts of overload for ~[]~ and ~[]=~ operators
  - rows :: ~appendRow~, ~insertRow~, ~addHeader~
  - columns :: ~insertCol~
  - whole grid :: ~fillToSize~

Helper functions for getting row/col count, iterating over
rows/columns

*** ~MulticellGrid~

Same as ~Seq2D~ (always rectangular with API preventing unwanted
modifications). Supports 'mutlicell' elements.

** ~hmisc/types/htrie~

Implementation of =trie= data structure. Not sure about performance,
mostly made for the sake of abstraction and API (storing list of paths
in tree).

** ~hmisc/types/hvariant~

Sum type as generic in nim. Similar to ~std::variant< ... >~. Not
really useful actually - after I wrote it there has never been a
situation where I case objects were just 'too much'.

** ~hmisc/types/colorstring~

Easier manipulation of colored strings in terminal. Support splitting
regular strin in same-color chunks, finding 'visible' length of the
string (as printed in terminal). Helper functions like ~toYellow()~ or
~toRed()~ to make creation of the colored strings simpler. All
attributes from ~terminal~ module are supported (fg/bg colors and
modifiers).

Provides two types for colored text - ~ColoredString~ (string +
styling) and ~ColoredRune~ (unicode rune + styling).


* Contribution & development

Most of the features in this library were implemented on
/do-it-when-I-need-it/ basis. Some of them are tested quite
extensively (sequence and tree mappings, colored strings), but more
unit test are always welcome. If you consider contributing and have
any questions about implementation or just want to clarify some things
(documentation might need more attention) feel free to join my
[[https://discord.gg/hjfYJCU][discord server]] and ask questions
there.

todo:
  - [ ] generic implementation of simple graph
  - [ ] basic graph algorithms
    - [ ] topological sorting
    - [ ] strongly connected components
